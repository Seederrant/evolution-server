// Generated by CoffeeScript 1.7.1
(function() {
  var EvolutionCommons, app, clone, evolution, gameId, gameInit, http, io, socketData;

  app = require("express")();

  http = require("http").Server(app);

  EvolutionCommons = require("./EvolutionCommons.js");

  io = require('socket.io')(http);

  evolution = require('./evolutionController.js')(io);

  gameId = 0;

  clone = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  gameInit = clone(evolution.games[0]);

  evolution.games[0].ec = new EvolutionCommons(evolution.games[0]);

  socketData = {};

  app.get("/", function(req, res) {
    res.send({
      connected: true
    });
  });

  io.on("connection", function(socket) {
    var ec, fakeTurn, game, goToFoodPhase, sData, validState;
    console.log("a user connected");
    sData = function() {
      return socketData[socket.id];
    };
    game = function() {
      return sData().game;
    };
    ec = function() {
      return game().ec;
    };
    validState = function(phase, playerId) {
      if (!ec().phase() === phase && ec().currentPlayerId === sData().playerId) {
        emit("evolution error", {
          message: "haloumi!"
        });
        return false;
      }
      return true;
    };
    fakeTurn = function(game) {
      var action;
      if (game.currentPlayerId !== socketsData().playerId) {
        game = game();
        action = {};
        action.previousPlayerId = game.currentPlayerId;
        evolution.nextPlayer(game);
        action.currentPlayerId = game.currentPlayerId;
        setTimeout(function() {
          socket.emit("player passed", action);
          fakeTurn(game);
        }, 5000);
      }
    };
    goToFoodPhase = function(socket, game) {
      var action;
      action = {};
      switch (game.players.length) {
        case 2:
          action.foodAmount = Math.ceil(Math.random() * 6) + 2;
          break;
        case 3:
          action.foodAmount = Math.ceil(Math.random() * 6) * Math.ceil(Math.random() * 6);
          break;
        case 4:
          action.foodAmount = Math.ceil(Math.random() * 6) * Math.ceil(Math.random() * 6) + 2;
      }
      socket.to(sData().room).emit("phase food", action);
      socket.emit("phase food", action);
    };
    socket.on('disconnect', function() {
      var _ref, _ref1;
      console.log("disconnect");
      if ((((_ref = sData()) != null ? _ref.gameId : void 0) != null) && (((_ref1 = sData()) != null ? _ref1.playerId : void 0) != null)) {
        console.log("disconnected: player: " + sData().playerId + ", game: " + sData().gameId);
        evolution.games[sData().gameId].players[sData().playerId].connected = false;
      }
      if (sData() != null) {
        delete sData();
      }
    });
    socket.on("pass phase evolution", function() {
      var nextPhase;
      if (!validState("Evolution")) {
        return;
      }
      nextPhase = ec().playerPassedEvolution();
      socket.to(sData().room).emit("player passed evolution");
      socket.emit("player passed evolution");
      if (nextPhase) {
        goToFoodPhase(socket, game());
      }
    });
    socket.on("end turn evolution", function(action) {
      var nextPhase, player;
      if (!validState("Evolution")) {
        return;
      }
      console.log("end turn evolution: ");
      console.log(action);
      if (ec().checkCompatibleEvolution(action.specieIndex, action.cardIndex)) {
        player = ec().currentPlayer();
        action.card = player.hand[action.cardIndex];
        nextPhase = ec().addTrait(action.specieIndex, action.cardIndex);
        socket.to(sData().room).emit("next player evolution", action);
        if (nextPhase) {
          goToFoodPhase(socket, game());
        }
      } else {
        action.message = "Error: cards are not compatible.";
        socket.emit("evolution error", action);
      }
    });
    socket.on("end turn food", function(action) {
      var nextPhase;
      if (!validState("Food")) {
        return;
      }
      console.log("end turn food: ");
      console.log(action);
      if (!ec().isFed(ec().specie(action.specieIndex))) {
        nextPhase = ec().feedSpecie(action.specieIndex);
        socket.to(sData().room).emit("next player food", action);
        if (nextPhase) {
          goToExtinctionPhase(socket, game());
        }
      } else {
        action.message = "Error: Specie is fed.";
        socket.emit("evolution error", action);
      }
    });
    socket.on("load game", function(data) {
      var filteredGame, playerId, _ref, _ref1;
      socketData[socket.id] = {};
      if ((data.gameId != null) && (data.playerId != null) && !((_ref = evolution.games[data.gameId]) != null ? (_ref1 = _ref.players[data.playerId]) != null ? _ref1.connected : void 0 : void 0)) {
        console.log("player existed");
        evolution.games[data.gameId].players[data.playerId].connected = true;
        sData().playerId = data.playerId;
        sData().gameId = data.gameId;
        sData().room = "game" + data.gameId;
      } else if (!((data.gameId != null) && (data.playerId != null))) {
        console.log("player did not exist");
        playerId = evolution.getNewPlayerId(gameId);
        sData().playerId = playerId;
        sData().gameId = gameId;
        evolution.games[gameId].players[playerId].connected = true;
        sData().room = "game" + gameId;
      } else {
        console.log("Error: player existed and was connected");
        socket.emit("game error", "A player is already connected on game " + data.gameId + " with the id " + data.playerId + ".");
        return;
      }
      socket.join(sData().room);
      console.log("load game " + data.gameId + " for player: " + data.playerId);
      sData().game = evolution.games[sData().gameId];
      filteredGame = evolution.filterGame(game(), sData().playerId);
      socket.emit("game loaded", {
        playerId: sData().playerId,
        gameId: sData().gameId,
        game: filteredGame
      });
    });
    socket.on("restart game", function() {
      console.log("restart game");
      evolution.games[0] = clone(gameInit);
      evolution.games[0].ec = new EvolutionCommons(evolution.games[0]);
      socket.to(sData().room).emit("evolution connect");
      socket.emit("evolution connect");
    });
    socket.on("error", function(error) {
      console.log(error);
      throw error;
    });
  });

  http.listen(3000, function() {
    console.log("listening on *:3000");
  });

}).call(this);

//# sourceMappingURL=index.map
